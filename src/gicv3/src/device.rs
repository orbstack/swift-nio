// References:
// - Learn the architecture - Generic Interrupt Controller v3 and v4, Overview (version 3.2)
// - Arm Generic Interrupt Controller Architecture Specification GIC architecture version 3 and version 4
// - https://wiki.osdev.org/Generic_Interrrupt_Controller
// - https://wiki.osdev.org/Generic_Interrupt_Controller_versions_3_and_4

// === Definitions === //

use std::collections::VecDeque;

use rustc_hash::FxHashMap;

use crate::mmio_util::BitPack;

/// The ID of an interrupt target that the GIC can route. The interrupt kind is determined by its ID.
/// Each ID corresponds to an *interrupt source*.
#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
pub struct InterruptId(pub u32);

impl InterruptId {
    pub const BITS: u32 = 10;

    // For more information about this classification, see section 2.2 of the specification.
    pub fn kind(self) -> InterruptKind {
        match self.0 {
            0..=15 => InterruptKind::SoftwareGenerated,
            16..=31 => InterruptKind::PrivatePeripheral,
            1056..=1119 => InterruptKind::PrivatePeripheral,
            32..=1019 => InterruptKind::SharedPeripheral,
            4096..=5119 => InterruptKind::SharedPeripheral,
            1020..=1023 => unreachable!("special interrupt number"),
            1024..=8191 => unreachable!("reserved"),
            _ => unreachable!("LPI interrupt ID is too big"),
        }
    }
}

/// The kind of an interrupt. Different interrupt kinds have different handling behavior.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum InterruptKind {
    /// **Shared Peripheral Interrupt**
    ///
    /// These are the IRQs that most internal and external peripherals generate to interact with the
    /// system.
    ///
    /// This is a peripheral interrupt that the Distributor can route to a specified PE that can
    /// handle the interrupt, or to a PE that is one of a group of PEs in the system that has been
    /// configured to accept this type of interrupt:
    ///
    /// - SPIs can be Group 0 interrupts, Secure Group 1 interrupts, or Non-secure Group 1 interrupts.
    /// - SPIs can support either edge-triggered or level-sensitive behavior.
    /// - SPIs are never routed using an ITS.
    /// - SPIs have an active state and therefore require explicit deactivation.
    ///
    SharedPeripheral,

    /// **Private Peripheral Interrupt**
    ///
    /// This is a peripheral interrupt that targets a single, specific PE, and different PEs can use
    /// the same interrupt number to indicate different events:
    /// - PPIs can be Group 0 interrupts, Secure Group 1 interrupts, or Non-secure Group 1 interrupts.
    /// - PPIs can support either edge-triggered or level-sensitive behavior.
    /// - PPIs are never routed using an ITS.
    /// - PPIs have an active state and therefore require explicit deactivation.
    ///
    /// ## Note
    ///
    /// Commonly, it is expected that PPIs are used by different instances of the same interrupt
    /// source on each PE, thereby allowing a common interrupt number to be used for PE-specific
    /// events, such as the interrupts from a private timer.
    PrivatePeripheral,

    /// **Software Generated Interrupt**
    ///
    /// SGIs are typically used for inter-processor communication, and are generated by a write to
    /// an SGI register in the GIC:
    ///
    /// - SGIs can be Group 0 interrupts, Secure Group 1 interrupts, or Non-secure Group 1 interrupts.
    /// - SGIs have edge-triggered behavior.
    /// - SGIs are never routed using an ITS.
    /// - SGIs have an active state and therefore require explicit deactivation.
    ///
    SoftwareGenerated,
}

/// An identifier for a CPU which gives information about its location.
///
/// For example, these could formatted as follows:
///
/// ```plain_text
/// <group of groups>.<group of processors>.<processor>.<core>
/// ```
///
/// ...although it's really up to the processor.
#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
pub struct Affinity(pub [u8; 4]);

impl Affinity {
    pub fn as_typer_id(self) -> u32 {
        BitPack::default()
            // In `GICR_TYPER`...
            // Bits [63:56] provide Aff3, the Affinity level 3 value for the Redistributor.
            .set_range(24, 31, self.0[3].into())
            // Bits [55:48] provide Aff2, the Affinity level 2 value for the Redistributor.
            .set_range(16, 23, self.0[2].into())
            // Bits [47:40] provide Aff1, the Affinity level 1 value for the Redistributor.
            .set_range(8, 15, self.0[1].into())
            // Bits [39:32] provide Aff0, the Affinity level 0 value for the Redistributor.
            .set_range(0, 7, self.0[0].into())
            .0
    }
}

/// Whether a given interrupt is edge-triggered or level-sensitive.
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub enum InterruptTrigger {
    /// An interrupt that is edge-triggered has the following property:
    ///
    /// - It is asserted on detection of a rising edge of an interrupt signal and then, regardless of
    ///   the state of the signal, remains asserted until the interrupt is acknowledged by software.
    ///
    EdgeTriggered,

    /// An interrupt that is level-sensitive has the following properties:
    ///
    /// - It is asserted whenever the interrupt signal level is active, and deasserted whenever the
    ///   level is not active.
    /// - It is explicitly deasserted by software.
    ///
    LevelSensitive,
}

impl InterruptTrigger {
    pub fn from_two_bit_repr(val: u32) -> Self {
        match val {
            0b10 => InterruptTrigger::EdgeTriggered,
            0b00 => InterruptTrigger::LevelSensitive,
            _ => unreachable!(),
        }
    }

    pub fn to_two_bit_repr(self) -> u32 {
        match self {
            InterruptTrigger::EdgeTriggered => 0b10,
            InterruptTrigger::LevelSensitive => 0b00,
        }
    }
}

/// The unique identifier for a *processing element*. These can be thought of as hardware threads,
/// each with their own set of registers.
#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]
pub struct PeId(pub u64);

/// The number of bits used to encode a priority value, from 4 to 8.
// N.B. We have to set this to something less than `6` to ensure that `gic_cpu_sys_reg_init` doesn't
// write to `ICC_AP1R1_EL1`, which causes an EL exception for some reason.
pub const PRIORITY_BITS: u64 = 4;

pub trait GicV3EventHandler {
    fn kick_vcpu_for_irq(&mut self, pe: PeId);

    fn is_vcpu_parked(&mut self, pe: PeId) -> bool;

    fn handle_custom_eoi(&mut self, pe: PeId, int_id: InterruptId);

    fn get_affinity(&mut self, pe: PeId) -> Affinity;
}

// === Device === //

#[derive(Debug, Default)]
pub struct GicV3 {
    // TODO: Replace with index vectors and, perhaps, perform an SOA transform to make bitmask queries
    //  considerably quicker. Also, a lot of bitmask handling could be done using CTZ.
    pub(crate) global_int_configs: FxHashMap<InterruptId, InterruptConfig>,
    pub(crate) local_int_configs: FxHashMap<(PeId, InterruptId), InterruptConfig>,
    pub(crate) pe_states: FxHashMap<PeId, PeState>,
    pub(crate) affinity_to_pe: FxHashMap<Affinity, PeId>,

    // TODO: Are these even necessary? Although they're mentioned in the kernel, it looks like they
    // only ever change during boot and it looks like our setup doesn't hit them.
    pub(crate) enable_are: bool,
    pub(crate) enable_grp_1: bool,
    pub(crate) enable_grp_0: bool,
}

impl GicV3 {
    pub(crate) fn affinity_to_pe(&self, affinity: Affinity) -> Option<PeId> {
        self.affinity_to_pe.get(&affinity).copied()
    }

    pub(crate) fn interrupt_config(&mut self, pe: PeId, id: InterruptId) -> &mut InterruptConfig {
        if id.kind() == InterruptKind::PrivatePeripheral {
            self.local_int_configs
                .entry((pe, id))
                .or_insert_with(|| InterruptConfig::new(pe, id))
        } else {
            self.global_int_configs
                .entry(id)
                .or_insert_with(|| InterruptConfig::new(pe, id))
        }
    }

    pub(crate) fn pe_state(
        &mut self,
        handler: &mut impl GicV3EventHandler,
        pe: PeId,
    ) -> &mut PeState {
        self.pe_states.entry(pe).or_insert_with(|| {
            let affinity = handler.get_affinity(pe);
            let replaced = self.affinity_to_pe.insert(affinity, pe);

            if let Some(replaced) = replaced {
                panic!("multiple PEs found with affinity {affinity:?}: {pe:?} and {replaced:?}");
            }

            log::trace!("Found new PE: {pe:?} -> {affinity:?}");

            PeState::new(affinity)
        })
    }

    pub fn send_spi(&mut self, handler: &mut impl GicV3EventHandler, int_id: InterruptId) {
        assert_eq!(int_id.kind(), InterruptKind::SharedPeripheral);

        // HACK: we ignore Linux's preference and effectively implement real-time irqbalance:
        // 1. try to send SPI to an awake vCPU
        for (pe, pe_state) in self.pe_states.iter_mut() {
            if !handler.is_vcpu_parked(*pe) {
                Self::send_interrupt_inner(handler, *pe, pe_state, int_id);
                return;
            }
        }

        // last resort: all vCPUs are asleep. wake up vCPU 0
        if let Some((pe, pe_state)) = self.pe_states.iter_mut().next() {
            Self::send_interrupt_inner(handler, *pe, pe_state, int_id);
        }
    }

    pub fn send_ppi(
        &mut self,
        handler: &mut impl GicV3EventHandler,
        pe: PeId,
        int_id: InterruptId,
    ) {
        assert_eq!(int_id.kind(), InterruptKind::PrivatePeripheral);

        let pe_state = self.pe_states.get_mut(&pe).unwrap();
        Self::send_interrupt_inner(handler, pe, pe_state, int_id);
    }

    pub(crate) fn send_interrupt_inner(
        handler: &mut impl GicV3EventHandler,
        pe: PeId,
        pe_state: &mut PeState,
        int_id: InterruptId,
    ) {
        // Check whether the target PE can receive the interrupt
        // TODO
        if !pe_state.is_enabled {
            log::trace!(
                "Ignoring interrupt {int_id:?} of type {:?} to {pe:?}",
                int_id.kind()
            );
        }

        // Push it to the queue
        // TODO: Prioritize these
        log::trace!(
            "Delivering interrupt {int_id:?} of type {:?} to {pe:?}",
            int_id.kind(),
        );
        pe_state.pending_interrupts.push_front(int_id);
        handler.kick_vcpu_for_irq(pe);
    }

    pub fn is_irq_line_asserted(&mut self, handler: &mut impl GicV3EventHandler, pe: PeId) -> bool {
        let pe_state = self.pe_state(handler, pe);
        !pe_state.pending_interrupts.is_empty() || pe_state.active_interrupt.is_some()
    }
}

#[derive(Debug)]
pub(crate) struct InterruptConfig {
    pub trigger: InterruptTrigger,
    pub disabled: bool,
    pub not_forwarded: bool,
    pub affinity: Affinity,
}

impl InterruptConfig {
    pub fn new(_pe: PeId, _id: InterruptId) -> Self {
        Self {
            // FIXME: This might not be correct.
            trigger: InterruptTrigger::EdgeTriggered,

            // 12.9.24: On a GIC reset, this field resets to 0.
            disabled: false,

            // 12.9.7: On a GIC reset, this field resets to an architecturally UNKNOWN value.
            not_forwarded: false,

            // 12.9.22: On a GIC reset, this field resets to an architecturally UNKNOWN value.
            affinity: Affinity([0; 4]),
        }
    }
}

#[derive(Debug)]
pub(crate) struct PeState {
    pub affinity: Affinity,
    pub min_priority: u8,
    pub is_enabled: bool,
    pub pending_interrupts: VecDeque<InterruptId>,
    pub active_interrupt: Option<InterruptId>,
}

impl PeState {
    pub fn new(affinity: Affinity) -> Self {
        Self {
            affinity,
            min_priority: 0,
            is_enabled: false,
            pending_interrupts: VecDeque::new(),
            active_interrupt: None,
        }
    }
}
