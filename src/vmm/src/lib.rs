// Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
//
// Portions Copyright 2017 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the THIRD-PARTY file.

//! Virtual Machine Monitor that leverages the Linux Kernel-based Virtual Machine (KVM),
//! and other virtualization features to run a single lightweight micro-virtual
//! machine (microVM).
//#![deny(missing_docs)]

#[macro_use]
extern crate tracing;

/// Handles setup and initialization a `Vmm` object.
pub mod builder;
pub(crate) mod device_manager;
/// Resource store for configured microVM resources.
pub mod resources;
/// Signal handling utilities.
#[cfg(target_os = "linux")]
pub mod signal_handler;
/// Wrappers over structures used to configure the VMM.
pub mod vmm_config;

#[cfg(target_os = "linux")]
mod linux;
#[cfg(target_os = "linux")]
use crate::linux::vstate;
#[cfg(target_os = "macos")]
mod macos;

use anyhow::anyhow;
use gruel::Subscriber;
use hvf::profiler::{Profiler, ProfilerParams};
#[cfg(target_os = "macos")]
pub use hvf::MemoryMapping;
#[cfg(target_os = "macos")]
use macos::vstate;
use mio::Interest;
use vmm_config::kernel_bundle::KernelBundle;
use vmm_ids::VmmShutdownSignal;

use crate::macos::VcpuRegistryImpl;
use std::fmt::{Display, Formatter};
use std::io;
use std::os::fd::RawFd;
use std::os::unix::io::AsRawFd;
use std::sync::{Arc, Weak};
#[cfg(target_os = "linux")]
use std::time::Duration;
use utils::Mutex;

#[cfg(target_arch = "x86_64")]
use crate::device_manager::legacy::PortIODeviceManager;
use crate::device_manager::mmio::MMIODeviceManager;
#[cfg(target_os = "linux")]
use crate::vstate::VcpuEvent;
use crate::vstate::{Vcpu, VcpuHandle, Vm};

use hvf::VcpuRegistry;

use arch::ArchMemoryInfo;
use arch::DeviceType;
use arch::InitrdConfig;
#[cfg(target_os = "macos")]
use crossbeam_channel::Sender;
use devices::virtio::VmmExitObserver;
use devices::ErasedBusDevice;
use kernel::cmdline::Cmdline as KernelCmdline;
use utils::eventfd::EventFd;
use utils::time::TimestampUs;
use vm_memory::{GuestAddress, GuestMemoryMmap};

/// Errors associated with the VMM internal logic. These errors cannot be generated by direct user
/// input, but can result from bad configuration of the host (for example if Firecracker doesn't
/// have permissions to open the KVM fd).
#[derive(Debug)]
pub enum Error {
    /// This error is thrown by the minimal boot loader implementation.
    ConfigureSystem(arch::Error),
    /// Legacy devices work with Event file descriptors and the creation can fail because
    /// of resource exhaustion.
    #[cfg(target_arch = "x86_64")]
    CreateLegacyDevice(device_manager::legacy::Error),
    /// Cannot read from an Event file descriptor.
    EventFd(io::Error),
    /// I8042 Error.
    I8042Error(devices::legacy::I8042DeviceError),
    /// Cannot access kernel file.
    KernelFile(io::Error),
    /// Cannot open /dev/kvm. Either the host does not have KVM or Firecracker does not have
    /// permission to open the file descriptor.
    KvmContext(vstate::Error),
    #[cfg(target_arch = "x86_64")]
    /// Cannot add devices to the Legacy I/O Bus.
    LegacyIOBus(device_manager::legacy::Error),
    /// Cannot load command line.
    LoadCommandline(kernel::cmdline::Error),
    /// Cannot add a device to the MMIO Bus.
    RegisterMMIODevice(device_manager::mmio::Error),
    /// Write to the serial console failed.
    Serial(io::Error),
    /// Cannot create Timer file descriptor.
    TimerFd(io::Error),
    /// Vcpu error.
    Vcpu(vstate::Error),
    /// Cannot send event to vCPU.
    VcpuEvent(vstate::Error),
    /// Cannot create a vCPU handle.
    VcpuHandle(vstate::Error),
    /// vCPU resume failed.
    VcpuResume,
    /// Cannot spawn a new Vcpu thread.
    VcpuSpawn(std::io::Error),
    /// Vm error.
    Vm(vstate::Error),
    /// Error thrown by observer object on Vmm initialization.
    VmmObserverInit(utils::errno::Error),
    /// Error thrown by observer object on Vmm teardown.
    VmmObserverTeardown(utils::errno::Error),
}

impl Display for Error {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        use self::Error::*;

        match self {
            ConfigureSystem(e) => write!(f, "System configuration error: {e:?}"),
            #[cfg(target_arch = "x86_64")]
            CreateLegacyDevice(e) => write!(f, "Error creating legacy device: {e:?}"),
            EventFd(e) => write!(f, "Event fd error: {e}"),
            I8042Error(e) => write!(f, "I8042 error: {e}"),
            KernelFile(e) => write!(f, "Cannot access kernel file: {e}"),
            KvmContext(e) => write!(f, "Failed to validate KVM support: {e:?}"),
            #[cfg(target_arch = "x86_64")]
            LegacyIOBus(e) => write!(f, "Cannot add devices to the legacy I/O Bus. {e}"),
            LoadCommandline(e) => write!(f, "Cannot load command line: {e}"),
            RegisterMMIODevice(e) => write!(f, "Cannot add a device to the MMIO Bus. {e}"),
            Serial(e) => write!(f, "Error writing to the serial console: {e:?}"),
            TimerFd(e) => write!(f, "Error creating timer fd: {e}"),
            Vcpu(e) => write!(f, "Vcpu error: {e}"),
            VcpuEvent(e) => write!(f, "Cannot send event to vCPU. {e:?}"),
            VcpuHandle(e) => write!(f, "Cannot create a vCPU handle. {e}"),
            VcpuResume => write!(f, "vCPUs resume failed."),
            VcpuSpawn(e) => write!(f, "Cannot spawn Vcpu thread: {e}"),
            Vm(e) => write!(f, "Vm error: {e}"),
            VmmObserverInit(e) => write!(
                f,
                "Error thrown by observer object on Vmm initialization: {e}"
            ),
            VmmObserverTeardown(e) => {
                write!(f, "Error thrown by observer object on Vmm teardown: {e}")
            }
        }
    }
}

/// Trait for objects that need custom initialization and teardown during the Vmm lifetime.
pub trait VmmEventsObserver {
    /// This function will be called during microVm boot.
    fn on_vmm_boot(&mut self) -> std::result::Result<(), utils::errno::Error> {
        Ok(())
    }
    /// This function will be called on microVm teardown.
    fn on_vmm_stop(&mut self) -> std::result::Result<(), utils::errno::Error> {
        Ok(())
    }
}

/// Shorthand result type for internal VMM commands.
pub type Result<T> = std::result::Result<T, Error>;

/// Contains the state and associated methods required for the Firecracker VMM.
pub struct Vmm {
    // Guest VM core resources.
    guest_memory: GuestMemoryMmap,
    arch_memory_info: ArchMemoryInfo,

    kernel_cmdline: KernelCmdline,

    vcpus_handles: Vec<VcpuHandle>,
    exit_evt: EventFd,
    vcpu_registry: Arc<VcpuRegistryImpl>,
    vm: Vm,
    shutdown: VmmShutdownSignal,
    exit_observers: Vec<Arc<Mutex<dyn VmmExitObserver>>>,

    profiler: Option<Weak<Profiler>>,

    // Guest VM devices.
    mmio_device_manager: MMIODeviceManager,
    #[cfg(target_arch = "x86_64")]
    pio_device_manager: PortIODeviceManager,
}

pub struct VmmShutdownHandle(pub EventFd);

impl VmmShutdownHandle {
    pub fn request_shutdown(&self) {
        tracing::debug!("Requesting hard shutdown for VMM");

        if let Err(e) = self.0.write() {
            error!("Failed to signal hard shutdown request: {}", e);
        }
    }
}

impl Vmm {
    pub fn exit_evt(&self) -> RawFd {
        self.exit_evt.as_raw_fd()
    }

    pub fn shutdown_handle(&self) -> VmmShutdownHandle {
        VmmShutdownHandle(self.exit_evt.try_clone().unwrap())
    }

    /// Gets the the specified bus device.
    pub fn get_bus_device(
        &self,
        device_type: DeviceType,
        device_id: &str,
    ) -> Option<&ErasedBusDevice> {
        self.mmio_device_manager.get_device(device_type, device_id)
    }

    /// Starts the microVM vcpus.
    pub fn start_vcpus(&mut self, mut vcpus: Vec<Vcpu>, entry_addr: GuestAddress) -> Result<()> {
        let vcpu_count = vcpus.len();

        Vcpu::register_kick_signal_handler();

        self.vcpus_handles.reserve(vcpu_count);

        for mut vcpu in vcpus.drain(..) {
            vcpu.set_mmio_bus(self.mmio_device_manager.bus.clone());

            self.vcpus_handles.push(
                vcpu.start_threaded(self.vcpu_registry.clone())
                    .map_err(Error::VcpuHandle)?,
            );
        }

        // The vcpus start off in the `Paused` state, let them run.
        self.resume_vcpus(entry_addr)?;

        Ok(())
    }

    /// Sends a resume command to the vcpus.
    #[cfg(target_os = "linux")]
    pub fn resume_vcpus(&mut self) -> Result<()> {
        for handle in self.vcpus_handles.iter() {
            handle
                .send_event(VcpuEvent::Resume)
                .map_err(Error::VcpuEvent)?;
        }
        for handle in self.vcpus_handles.iter() {
            match handle
                .response_receiver()
                .recv_timeout(Duration::from_millis(1000))
            {
                Ok(VcpuResponse::Resumed) => (),
                _ => return Err(Error::VcpuResume),
            }
        }
        Ok(())
    }

    #[cfg(target_os = "macos")]
    pub fn resume_vcpus(&mut self, entry_addr: GuestAddress) -> Result<()> {
        // boot the first vCPU
        self.vcpus_handles[0].boot(entry_addr);
        Ok(())
    }

    /// Configures the system for boot.
    pub fn configure_system(
        &self,
        vcpus: &[Vcpu],
        initrd: &Option<InitrdConfig>,
        _kernel_bundle: &Option<KernelBundle>,
    ) -> Result<()> {
        #[cfg(target_arch = "x86_64")]
        {
            let cmdline_len = if cfg!(feature = "tee") {
                arch::x86_64::layout::CMDLINE_SEV_SIZE
            } else {
                self.kernel_cmdline.len() + 1
            };

            arch::x86_64::configure_system(
                &self.guest_memory,
                &self.arch_memory_info,
                vm_memory::GuestAddress(arch::x86_64::layout::CMDLINE_START),
                cmdline_len,
                initrd,
                vcpus.len() as u8,
                _kernel_bundle
                    .as_ref()
                    .map(|k| k.params)
                    .unwrap_or_default(),
            )
            .map_err(Error::ConfigureSystem)?;
        }

        #[cfg(all(target_arch = "aarch64", target_os = "linux"))]
        {
            let vcpu_mpidr = vcpus.iter().map(|cpu| cpu.get_mpidr()).collect();
            arch::aarch64::configure_system(
                &self.guest_memory,
                &self.arch_memory_info,
                self.kernel_cmdline.as_str(),
                vcpu_mpidr,
                self.mmio_device_manager.get_device_info(),
                self.vm.get_irqchip(),
                initrd,
            )
            .map_err(Error::ConfigureSystem)?;
        }

        #[cfg(all(target_arch = "aarch64", target_os = "macos"))]
        {
            let vcpu_mpidr = vcpus.iter().map(|cpu| cpu.get_mpidr()).collect();
            arch::aarch64::configure_system(
                &self.guest_memory,
                &self.arch_memory_info,
                self.kernel_cmdline.as_str(),
                vcpu_mpidr,
                self.mmio_device_manager.get_device_info(),
                self.vm.get_irqchip(),
                initrd,
            )
            .map_err(Error::ConfigureSystem)?;
        }
        Ok(())
    }

    /// Returns a reference to the inner `GuestMemoryMmap` object if present, or `None` otherwise.
    pub fn guest_memory(&self) -> &GuestMemoryMmap {
        &self.guest_memory
    }

    /// Injects CTRL+ALT+DEL keystroke combo in the i8042 device.
    #[cfg(target_arch = "x86_64")]
    pub fn send_ctrl_alt_del(&mut self) -> Result<()> {
        self.pio_device_manager
            .i8042
            .lock()
            .expect("i8042 lock was poisoned")
            .trigger_ctrl_alt_del()
            .map_err(Error::I8042Error)
    }

    fn wait_for_observers_to_exit(&mut self) {
        for observer in &self.exit_observers {
            let mut observer = observer.lock().expect("Poisoned mutex for exit observer");

            debug!("Calling exit observer: {:?}", observer.type_name());
            observer.on_vmm_exit();
            debug!("Finished calling exit observer: {:?}", observer.type_name());
        }
    }

    #[cfg(target_os = "linux")]
    fn log_boot_time(t0_ts: &TimestampUs) {
        let now_tm_us = TimestampUs::default();

        let boot_time_us = now_tm_us.time_us - t0_ts.time_us;
        let boot_time_cpu_us = now_tm_us.cputime_us - t0_ts.cputime_us;
        info!(
            "Guest-boot-time = {:>6} us {} ms, {:>6} CPU us {} CPU ms",
            boot_time_us,
            boot_time_us / 1000,
            boot_time_cpu_us,
            boot_time_cpu_us / 1000
        );
    }

    /// Returns a reference to the inner KVM Vm object.
    pub fn kvm_vm(&self) -> &Vm {
        &self.vm
    }

    #[cfg(target_os = "macos")]
    pub unsafe fn add_mapping(
        &self,
        reply_sender: Sender<bool>,
        host_addr: *mut u8,
        guest_addr: GuestAddress,
        len: usize,
    ) {
        self.vm
            .add_mapping(reply_sender, host_addr, guest_addr, len);
    }

    #[cfg(target_os = "macos")]
    pub fn remove_mapping(&self, reply_sender: Sender<bool>, guest_addr: GuestAddress, len: usize) {
        self.vm.remove_mapping(reply_sender, guest_addr, len);
    }

    pub fn shutdown_signal_for_subscribing(&self) -> VmmShutdownSignal {
        self.shutdown.clone()
    }

    pub fn dump_debug(&self) {
        self.vcpu_registry.dump_debug();
    }

    pub fn start_profile(&mut self, params: &ProfilerParams) -> anyhow::Result<()> {
        if let Some(profiler) = &self.profiler {
            if profiler.upgrade().is_some() {
                return Err(anyhow!("profiler is already running"));
            } else {
                self.profiler = None;
            }
        }

        let profiler = Arc::new(Profiler::new(params.clone(), self.vcpu_registry.clone()));
        profiler.start()?;

        // downgrade to Weak so that profiler can stop by itself without leaking memory
        self.profiler = Some(Arc::downgrade(&profiler));
        Ok(())
    }

    pub fn stop_profile(&mut self) -> anyhow::Result<()> {
        if let Some(profiler) = self.profiler.take() {
            if let Some(profiler) = profiler.upgrade() {
                profiler.stop()?;
            }
        }

        Ok(())
    }
}

impl Subscriber for Vmm {
    type EventMeta = RawFd;

    fn process_event(
        &mut self,
        ctrl: &mut gruel::InterestCtrl<'_, RawFd>,
        event: &mio::event::Event,
        &mut source: &mut RawFd,
    ) {
        if source == self.exit_evt.as_raw_fd() && event.is_readable() {
            let _ = self.exit_evt.read();
            self.shutdown.shutdown();
            self.wait_for_observers_to_exit();
            self.vm.destroy_hvf();

            // FIXME: Gruel
            // You might be thinking: what happens if other subscribers handle events after this? And,
            // the answer is: no clue! `polly` did things this way so I'm leaving it like that for
            // now but we should really find a better shutdown order.
            ctrl.stop();
        } else {
            error!("Spurious EventManager event for handler: Vmm");
        }
    }

    fn init_interests(&self, ctrl: &mut gruel::InterestCtrl<'_, RawFd>) {
        ctrl.register_fd(&self.exit_evt, Interest::READABLE);
    }
}
