#!/usr/bin/env bash

#
# Copyright 2023 Danny Lin <danny@kdrag0n.dev>. All rights reserved.
# 
# Unauthorized copying of this software and associated documentation files (the "Software"), via any medium, is strictly prohibited. Confidential and proprietary.
# 
# The above copyright notice shall be included in all copies or substantial portions of the Software.
#

set -uo pipefail

echo "[BEGIN] vinit-early"

# net
echo 0 > /proc/sys/net/ipv6/conf/eth0/accept_ra
echo 0 > /proc/sys/net/ipv6/conf/eth0/accept_dad # fix tentative ipv6 delay
# static neigh
ip neigh add 198.19.248.1 lladdr da:9b:d0:64:e1:01 dev eth0
ip neigh add 198.19.248.200 lladdr da:9b:d0:64:e1:01 dev eth0
ip neigh add 198.19.248.201 lladdr da:9b:d0:64:e1:01 dev eth0
ip neigh add 198.19.248.253 lladdr da:9b:d0:64:e1:01 dev eth0
ip neigh add 198.19.248.254 lladdr da:9b:d0:64:e1:01 dev eth0
# we use diff subnet for other v6
ip -6 neigh add fd07:b51a:cc66:00f0::1 lladdr da:9b:d0:64:e1:01 dev eth0
# config
ip link set eth0 mtu 1500
ip link set eth0 up
ip addr add 198.19.248.2/24 dev eth0
ip route add default via 198.19.248.1 dev eth0
ip addr add fd07:b51a:cc66:00f0::2/64 dev eth0
ip route add default via fd07:b51a:cc66:00f0::1 dev eth0
# bridge
# scon deals with the rest
# cannot use static neigh because macOS generates MAC addr
ip link set eth1 mtu 1500
ip link set eth1 up
# docker
# scon deals with the rest
ip link set eth2 mtu 1500
ip link set eth2 up

# control server
# must be after net for IP
ip link set lo up # too early
/opt/orb/vcontrol &
echo -n -1000 > /proc/$!/oom_score_adj

# early disk perf
echo none > /sys/block/vda/queue/scheduler
echo none > /sys/block/vdb/queue/scheduler
echo none > /sys/block/vdc/queue/scheduler

# resize data
# parse orb.data_size=10240 from /proc/cmdline
data_size=$(cat /proc/cmdline | sed 's/ /\n/g' | grep orb.data_size= | sed 's/orb.data_size=//g') || true
if [[ -n "$data_size" ]]; then
    # get existing size
    old_size_bytes=$(blockdev --getsize64 /dev/vdb1)
    old_size=$((old_size_bytes / 1024 / 1024))
    # for safety, only allow increasing size
    if [[ "$old_size" -lt "$data_size" ]]; then
        echo "resize data to $data_size"
        echo ",${data_size}M" | sfdisk --force /dev/vdb
        # FS must be resized in vinit-late
        # XFS can only be resized online
    elif [[ "$old_size" -gt "$data_size" ]]; then
        echo "attempt to reduce data size: $data_size"
    fi
fi

# virtiofs share
mount -t virtiofs mac /mnt/mac

# rosetta
mount -t binfmt_misc binfmt_misc /proc/sys/fs/binfmt_misc
if mount -t virtiofs rosetta /mnt/rosetta; then
    echo -n ':rosetta:M:0:\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x3e\x00:\xff\xff\xff\xff\xff\xfe\xfe\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:[rosetta]:CF@' > /proc/sys/fs/binfmt_misc/register
    # rosetta doesn't support 32-bit
    echo -n ':qemu-i386:M:0:\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00:\xff\xff\xff\xff\xff\xfe\xfe\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:[qemu32]:POCF' > /proc/sys/fs/binfmt_misc/register
elif [[ "$(uname -m)" == "aarch64" ]]; then
    # use qemu instead
    echo -n ':qemu-x86_64:M:0:\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x3e\x00:\xff\xff\xff\xff\xff\xfe\xfe\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:[qemu]:POCF' > /proc/sys/fs/binfmt_misc/register
    echo -n ':qemu-i386:M:0:\x7f\x45\x4c\x46\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x03\x00:\xff\xff\xff\xff\xff\xfe\xfe\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:[qemu32]:POCF' > /proc/sys/fs/binfmt_misc/register
elif [[ "$(uname -m)" == "x86_64" ]]; then
    # arm64 qemu for x86_64
    echo -n ':qemu-aarch64:M:0:\x7fELF\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\xb7\x00:\xff\xff\xff\xff\xff\xff\xff\x00\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff:[qemu-arm64]:POCF' > /proc/sys/fs/binfmt_misc/register
fi

# mach-o binfmt
# no O because fds can't cross OS boundary
# no C because credentials are ignored
# macOS doesn't support 32-bit anymore
# 07 = x86
echo -n ':mac-macho-x86_64:M:0:\xcf\xfa\xed\xfe\x07\x00\x00\x01:\xff\xff\xff\xff\xff\xff\xff\xff:[mac]:FP' > /proc/sys/fs/binfmt_misc/register
if [[ "$(uname -m)" == "aarch64" ]]; then
    # 0c = arm64
    echo -n ':mac-macho-arm64:M:0:\xcf\xfa\xed\xfe\x0c\x00\x00\x01:\xff\xff\xff\xff\xff\xff\xff\xff:[mac]:FP' > /proc/sys/fs/binfmt_misc/register
fi

# universal
# accepts both 1 and 2 binaries, with either arch first
# no conflict with java: https://github.com/file/file/blob/c8bba134ac1f3c9f5b052486a7694c5b48e498bc/magic/Magdir/cafebabe#L3
echo -n ':mac-universal-x86_64:M:0:\xca\xfe\xba\xbe\x00\x00\x00\x02\x01\x00\x00\x07:\xff\xff\xff\xff\xff\xff\xff\x02\xff\xff\xff\xff:[mac]:FP' > /proc/sys/fs/binfmt_misc/register
echo -n ':mac-universal-arm64:M:0:\xca\xfe\xba\xbe\x00\x00\x00\x02\x01\x00\x00\x0c:\xff\xff\xff\xff\xff\xff\xff\x02\xff\xff\xff\xff:[mac]:FP' > /proc/sys/fs/binfmt_misc/register

echo "[END] vinit-early"
