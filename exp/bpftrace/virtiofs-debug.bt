
#include <linux/socket.h>
#include <sys/socket.h>
#include <stdbool.h>
enum fuse_opcode {
	FUSE_LOOKUP		= 1,
	FUSE_FORGET		= 2,  /* no reply */
	FUSE_GETATTR		= 3,
	FUSE_SETATTR		= 4,
	FUSE_READLINK		= 5,
	FUSE_SYMLINK		= 6,
	FUSE_MKNOD		= 8,
	FUSE_MKDIR		= 9,
	FUSE_UNLINK		= 10,
	FUSE_RMDIR		= 11,
	FUSE_RENAME		= 12,
	FUSE_LINK		= 13,
	FUSE_OPEN		= 14,
	FUSE_READ		= 15,
	FUSE_WRITE		= 16,
	FUSE_STATFS		= 17,
	FUSE_RELEASE		= 18,
	FUSE_FSYNC		= 20,
	FUSE_SETXATTR		= 21,
	FUSE_GETXATTR		= 22,
	FUSE_LISTXATTR		= 23,
	FUSE_REMOVEXATTR	= 24,
	FUSE_FLUSH		= 25,
	FUSE_INIT		= 26,
	FUSE_OPENDIR		= 27,
	FUSE_READDIR		= 28,
	FUSE_RELEASEDIR		= 29,
	FUSE_FSYNCDIR		= 30,
	FUSE_GETLK		= 31,
	FUSE_SETLK		= 32,
	FUSE_SETLKW		= 33,
	FUSE_ACCESS		= 34,
	FUSE_CREATE		= 35,
	FUSE_INTERRUPT		= 36,
	FUSE_BMAP		= 37,
	FUSE_DESTROY		= 38,
	FUSE_IOCTL		= 39,
	FUSE_POLL		= 40,
	FUSE_NOTIFY_REPLY	= 41,
	FUSE_BATCH_FORGET	= 42,
	FUSE_FALLOCATE		= 43,
	FUSE_READDIRPLUS	= 44,
	FUSE_RENAME2		= 45,
	FUSE_LSEEK		= 46,
	FUSE_COPY_FILE_RANGE	= 47,
	FUSE_SETUPMAPPING	= 48,
	FUSE_REMOVEMAPPING	= 49,
	FUSE_SYNCFS		= 50,
	FUSE_TMPFILE		= 51,

	/* CUSE specific operations */
	CUSE_INIT		= 4096,

	/* Reserved opcodes: helpful to detect structure endian-ness */
	CUSE_INIT_BSWAP_RESERVED	= 1048576,	/* CUSE_INIT << 8 */
	FUSE_INIT_BSWAP_RESERVED	= 436207616,	/* FUSE_INIT << 24 */
};

/** One input argument of a request */
/*struct fuse_in_arg {
	unsigned size;
	const void *value;
};*/

/** One output argument of a request */
/*struct fuse_arg {
	unsigned size;
	void *value;
};

struct fuse_args {
	unsigned long long nodeid;
	unsigned int opcode;
	unsigned short in_numargs;
	unsigned short out_numargs;
	bool b1;
    bool b2;
	struct fuse_in_arg in_args[3];
	struct fuse_arg out_args[2];
};*/

BEGIN
{
    printf("Tracing fuse...\n");
    // from the enum above
    @opcodes[1] = "lookup";
    @opcodes[2] = "forget";
    @opcodes[3] = "getattr";
    @opcodes[4] = "setattr";
    @opcodes[5] = "readlink";
    @opcodes[6] = "symlink";
    @opcodes[8] = "mknod";
    @opcodes[9] = "mkdir";
    @opcodes[10] = "unlink";
    @opcodes[11] = "rmdir";
    @opcodes[12] = "rename";
    @opcodes[13] = "link";
    @opcodes[14] = "open";
    @opcodes[15] = "read";
    @opcodes[16] = "write";
    @opcodes[17] = "statfs";
    @opcodes[18] = "release";
    @opcodes[20] = "fsync";
    @opcodes[21] = "setxattr";
    @opcodes[22] = "getxattr";
    @opcodes[23] = "listxattr";
    @opcodes[24] = "removexattr";
    @opcodes[25] = "flush";
    @opcodes[26] = "init";
    @opcodes[27] = "opendir";
    @opcodes[28] = "readdir";
    @opcodes[29] = "releasedir";
    @opcodes[30] = "fsyncdir";
    @opcodes[31] = "getlk";
    @opcodes[32] = "setlk";
    @opcodes[33] = "setlkw";
    @opcodes[34] = "access";
    @opcodes[35] = "create";
    @opcodes[36] = "interrupt";
    @opcodes[37] = "bmap";
    @opcodes[38] = "destroy";
    @opcodes[39] = "ioctl";
    @opcodes[40] = "poll";
    @opcodes[41] = "notify_reply";
    @opcodes[42] = "batch_forget";
    @opcodes[43] = "fallocate";
    @opcodes[44] = "readdirplus";
    @opcodes[45] = "rename2";
    @opcodes[46] = "lseek";
    @opcodes[47] = "copy_file_range";
    @opcodes[48] = "setupmapping";
    @opcodes[49] = "removemapping";
    @opcodes[50] = "syncfs";
    @opcodes[51] = "tmpfile";
}

kprobe:queue_request_and_unlock
{
    $req = (struct fuse_req *)arg1;
    $unique = $req->in.h.unique;

    @start[$unique] = nsecs;
    @iopid[$unique] = pid;
    @iocomm[$unique] = comm;
    @tid_unique[tid] = $unique;
}

kretprobe:virtqueue_kick_prepare
/@tid_unique[tid]/
{
    $unique = @tid_unique[tid];

    $now = nsecs;
    printf("queue_request_and_unlock: [%s]  - %d µs\n", @iocomm[$unique], ($now - @start[$unique]) / 1000);
    delete(@tid_unique[tid]);
}

kprobe:virtio_fs_request_complete
{
    $req = (struct fuse_req *)arg0;
    $opcode = $req->in.h.opcode;
    $unique = $req->in.h.unique;

    $type = (($req->flags & (1<<2)) != 0) ? " | bg" : "";
    $now = nsecs;
    @total_usecs = lhist(($now - @start[$unique]) / 1000, 0, 1000, 50);
	printf("total: [%s%s] %10s - %d µs", @iocomm[$unique], $type, @opcodes[$req->in.h.opcode], ($now - @start[$unique]) / 1000);
    /*if ($opcode == FUSE_LOOKUP) {
        printf(" %s", str($req->args->in_args[0].value));
    }*/
    printf("\n\n");

    delete(@start[$unique]);
    delete(@iopid[$unique]);
    delete(@iocomm[$unique]);
}

kprobe:virtio_fs_vq_done
{
    $vq = (struct virtqueue *)arg0;
    $last = @vq_last[$vq];
    $now = nsecs;
    printf("host: %d µs\n", ($now - $last) / 1000);

    @last_time[1] = $now;
}

kprobe:virtqueue_notify
{
    $vq = (struct virtqueue *)arg0;
    @vq_last[$vq] = nsecs;
}

kprobe:virtio_fs_complete_req_work
{
    printf("doing async complete work\n");
}

kprobe:virtio_fs_requests_done_work
{
    $work = (struct work_struct *)arg0;
    $now = nsecs;
    printf("schedule work:  +%d µs\n", ($now - @last_time[1]) / 1000);
}

END
{
    clear(@opcodes);
    clear(@start);
    clear(@iopid);
    clear(@iocomm);
    clear(@tid_unique);
    clear(@vq_last);
    clear(@last_time);
}
