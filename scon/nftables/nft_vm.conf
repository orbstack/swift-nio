# slightly special syntax here:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_VNET = eth0 #DEFAULT
define IF_BRIDGE = conbr0 #DEFAULT
define INTERNAL_LISTEN_IP4 = 198.19.248.2 #DEFAULT
define INTERNAL_LISTEN_IP6 = fd07:b51a:cc66:f0::2 #DEFAULT
define SCON_WEB_INDEX_IP4 = 198.19.249.1 #DEFAULT
define SCON_WEB_INDEX_IP6 = fd07:b51a:cc66:0::1 #DEFAULT
define SCON_HOST_BRIDGE_IP4 = 198.19.249.3 #DEFAULT
define SCON_HOST_BRIDGE_IP6 = fd07:b51a:cc66:0:a617:db5e:0ab7:e9f1 #DEFAULT
define MAC_DOCKER = 1a:78:30:64:16:a9 #DEFAULT
define VNET_SECURE_SVC_IP4 = 198.19.248.201 #DEFAULT
define PORT_SECURE_SVC_DOCKER_REMOTE_CTX = 2376 #DEFAULT
define SCON_SUBNET4 = 198.19.249.0/24 #DEFAULT
define SCON_SUBNET6 = fd07:b51a:cc66::/64 #DEFAULT
define VNET_SUBNET4 = 198.19.248.0/24 #DEFAULT
define VNET_SUBNET6 = fd07:b51a:cc66:f0::/64 #DEFAULT

table inet vm {
    map tcp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map udp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map tcp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    map udp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    set block_docker_subnets4 {
        type ipv4_addr
        # CIDRs
        flags interval
        auto-merge
    }

    set block_docker_subnets6 {
        type ipv6_addr
        # CIDRs
        flags interval
        auto-merge
    }

    flowtable ft {
        hook ingress priority filter
        # no eth1: it's a member of conbr0
        # no eth2: forwarded packets are in docker machine
        devices = { $IF_BRIDGE, $IF_VNET }
    }

    chain prerouting-early {
        type filter hook prerouting priority raw; policy accept;

        # reverse path filter for internal services
        # prevents machines from hijacking existing internal TCP conns
        # we don't do this for all IPs for performance, and because it could cause issues with NAT64 fib routing
        # but the vnet subnet is usually not perf critical
        # rule: raw -> [conntrack] -> mangle -> nat -> filter
        # TODO: this works but... seems roundabout
        ip daddr $VNET_SUBNET4 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
        ip6 daddr $VNET_SUBNET6 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
    }

    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # fast port forwards
        # MASQUERADE not needed
        # this preserves source IP from host vnet, which works due to ip forward
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards4
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards4
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards6
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards6
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # NAT: gvisor only accepts packets with our source IP
        # filtering by output interface fixes multicast
        # can't filter by input interface (-i) in POSTROUTING
        # TODO: remove saddr
        ip saddr $SCON_SUBNET4 oif $IF_VNET counter masquerade
        ip6 saddr $SCON_SUBNET6 oif $IF_VNET counter masquerade
    }

    chain input {
        type filter hook input priority filter; policy drop;

        # related/established
        # this has no counter (even in debug) because it's hot: all VM conns hit this
        ct state established,related accept

        # loopback and host: allow mac gvisor vnet to access anything
        iif { lo, $IF_VNET } counter accept

	    # icmp: allow all ICMP for ping and neighbor solicitation
        meta l4proto { icmp, ipv6-icmp } counter accept

        # 67/udp: allow machines to use DHCP v4 server (dnsmasq)
        # 5353/udp: allow machines to use mDNS server
        iif $IF_BRIDGE udp dport { 67, 5353 } counter accept

        # allow mac host bridge to access web server ports 80 and 443
        # block machines because it could leak info to isolated machines
        # TODO: only exclude isolated machine src
        ip saddr $SCON_HOST_BRIDGE_IP4 ip daddr $SCON_WEB_INDEX_IP4 iif $IF_BRIDGE tcp dport { 80, 443 } counter accept
        ip6 saddr $SCON_HOST_BRIDGE_IP6 ip6 daddr $SCON_WEB_INDEX_IP6 iif $IF_BRIDGE tcp dport { 80, 443 } counter accept

        # explicitly block machines from accessing VM init-net servers that are intended for host vmgr to connect to
        # TODO: after initial test, change to policy reject and remove this line
        iif $IF_BRIDGE meta l4proto tcp counter reject
    }

    chain forward {
        # TODO: policy drop
        type filter hook forward priority filter; policy accept;

        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        meta l4proto { tcp, udp } flow add @ft counter

        # related/established
        ct state established,related counter accept

        # now, the real purpose of policy=DROP for FORWARD is to prevent routing loops
        # to do so, we prepend/delete rules when creating bridges
        # Linux will never ip-forward conbr0 subnet to eth0 since it's a local route on conbr0, so no need to worry about that. only vlan bridges are at risk because the netns is different, and because we do L3 forwarding for them
        ip daddr @block_docker_subnets4 iif $IF_BRIDGE oif $IF_VNET ether saddr $MAC_DOCKER counter drop
        ip6 daddr @block_docker_subnets6 iif $IF_BRIDGE oif $IF_VNET ether saddr $MAC_DOCKER counter drop

        # limit access to secure services:
		# allow secureSvcIP:SecureSvcDockerRemoteCtx from docker
		# will be covered by MAC protection from isolated machines in the future
		# non-isolated machines can already access any socket by running commands on host
        ip daddr $VNET_SECURE_SVC_IP4 iif $IF_BRIDGE ether saddr $MAC_DOCKER tcp dport $PORT_SECURE_SVC_DOCKER_REMOTE_CTX counter accept
		# block other secure svc
        # TODO: remove iif
        ip daddr $VNET_SECURE_SVC_IP4 iif $IF_BRIDGE reject

	    # allow machines to access any internet address, via gvisor
	    # this includes private IPs and everything else
	    # don't allow forwarding to any other interfaces we may add to machine in the future
        iif $IF_BRIDGE oif $IF_VNET counter accept
	    # reverse forward uses MASQUERADE but it's still subject to FORWARD
	    # can't filter by ctstate ESTABLISHED/RELATED because DNAT port forwards use this path too
        iif $IF_VNET oif $IF_BRIDGE counter accept

        # allow machines to talk to each other, and to macOS host bridge IP
        # this is bridge but still counts as forward
        # TODO: why?
        iif $IF_BRIDGE oif $IF_BRIDGE counter accept
    }
}
