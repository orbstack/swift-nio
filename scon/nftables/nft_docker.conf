# special syntax:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_SCON = eth0 #DEFAULT
define DOCKER_MARK_TLS_PROXY_UPSTREAM = 0x9f7a0000 #DEFAULT
define DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE = 0xb3c60000 #DEFAULT
define VNET_TLS_PROXY_IP4 = 198.19.248.65 #DEFAULT
define VNET_TLS_PROXY_IP6 = fd07:b51a:cc66:f0::41 #DEFAULT
define PORT_DOCKER_MACHINE_TLS_PROXY = 30817 #DEFAULT
define VNET_GATEWAY_IP4 = 198.19.248.1 #DEFAULT
define VNET_GATEWAY_IP6 = fd07:b51a:cc66:f0::1 #DEFAULT
define SCON_SUBNET6_CIDR = fd07:b51a:cc66:0::/64 #DEFAULT
define NAT64_SOURCE_IP4 = 10.183.233.241 #DEFAULT

# all chains have higher prio than docker/k8s iptables-nft
table inet orbstack {
    set docker_bridges {
        type ifname
    }

    set host_bridge_ports {
        type ifname
    }

    set docker_bridge_subnets4 {
        type ipv4_addr
        flags interval
        auto-merge
    }

    set docker_bridge_subnets6 {
        type ipv6_addr
        flags interval
        auto-merge
    }

    # TODO: remove
    set docker_bridge_gateways4 {
        type ipv4_addr
    }

    set docker_bridge_gateways6 {
        type ipv6_addr
    }

    flowtable ft {
        hook ingress priority filter
        # TODO: safe to do this for orbmirror, or does return route break?
        devices = { $IF_SCON }
    }

    chain prerouting {
        type nat hook prerouting priority dstnat - 1; policy accept;

        # 172.17.0.1 IP gateway compat. people hard code this...
        # redirect to local IP on same interface (eth0, i.e. 198.19.249.2 docker machine's external IP) 
        # only do so if packet would otherwise go out to internet, in case user is using 172.17/16
        ip daddr 172.17.0.1 fib daddr . mark oif eq $IF_SCON counter redirect
    }

    chain postrouting {
        type nat hook postrouting priority srcnat - 1; policy accept;

        # "fix" ipv4 docker port forward source IP as seen by container servers:
        # normally docker only does DNAT w/o MASQUERADE to preserve source IP, but our source IP is internal vnet and people expect it to come from the machine like normal linux loopback
        # needed because people make assumptions about source IPs
        ip saddr { $VNET_GATEWAY_IP4, $NAT64_SOURCE_IP4 } iif $IF_SCON counter masquerade
        ip6 saddr $VNET_GATEWAY_IP6 iif $IF_SCON counter masquerade

        # VM can only route the /64 ULA that the machine was assigned
        # masquerade other outgoing IPv6 traffic to fix kind ipv6 access
        # TODO: what was this for???
        ip6 saddr fc00::/7 ip6 saddr != $SCON_SUBNET6_CIDR oif eth0 counter masquerade

        # prevent routing loop: a packet received from macOS bridge must not be sent back to macOS
        iifname @host_bridge_ports oif $IF_SCON counter drop
    }

    chain early-prerouting {
        type filter hook prerouting priority mangle; policy accept;

        # *** TLS proxy 
        # complicated routing to make source IP spoofing work:
        # 1. outgoing socket has SO_MARK set to TlsProxyUpstreamMarkStr
        # 2. on OUTPUT path, save the OUTGOING mark to conntrack metadata for this 5-tuple
        # 3. on *input* PREROUTING path, restore the mark from conntrack metadata
        # 4. on *input* path ONLY, *change* mark from OUTGOING (UpstreamMark) to LOCAL_ROUTE (LocalRouteMark)
        # this achieves asymmetrical routing: packets with this mark are *outgoing* on egress path, and hijacked to *loopback* on ingress path
        ct mark $DOCKER_MARK_TLS_PROXY_UPSTREAM counter meta mark set $DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE

        jump early-prerouting-dynamic
    }

    chain early-prerouting-dynamic {
        # added dynamically by DockerTlsInitCommands
        #jump early-prerouting-tproxy
    }

    chain early-prerouting-tproxy {
        # TPROXY: redirect incoming port 443 traffic to containers to our proxies
        # exclude our gateway IP (pkttype host) to avoid breaking port forward access
        # match dport 443 first to avoid perf hit on other conns (-10 Gbps)
        tcp dport 443 ip daddr @docker_bridge_subnets4 ip daddr != @docker_bridge_gateways4 meta mark != $DOCKER_MARK_TLS_PROXY_UPSTREAM counter meta mark set $DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE tproxy ip to $VNET_TLS_PROXY_IP4:$PORT_DOCKER_MACHINE_TLS_PROXY
        tcp dport 443 ip6 daddr @docker_bridge_subnets6 ip6 daddr != @docker_bridge_gateways6 meta mark != $DOCKER_MARK_TLS_PROXY_UPSTREAM counter meta mark set $DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE tproxy ip6 to $VNET_TLS_PROXY_IP6:$PORT_DOCKER_MACHINE_TLS_PROXY
    }

    chain early-output {
        type route hook output priority mangle; policy accept;

        # TLS PROXY - 2. on OUTPUT path, save the OUTGOING mark to conntrack metadata for this 5-tuple
        meta mark $DOCKER_MARK_TLS_PROXY_UPSTREAM counter ct mark set mark
    }

    chain early-forward {
        type filter hook forward priority filter - 1; policy accept;

        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        meta l4proto { tcp, udp } flow add @ft counter
    }
}
