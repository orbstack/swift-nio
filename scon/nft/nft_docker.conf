# special syntax:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_SCON = eth0 #DEFAULT
define VNET_TLS_PROXY_IP4 = 0.0.250.65 #DEFAULT
define VNET_TLS_PROXY_IP6 = fd07:b51a:cc66:f0::41 #DEFAULT
define VNET_GATEWAY_IP4 = 0.0.250.1 #DEFAULT
define VNET_GATEWAY_IP6 = fd07:b51a:cc66:f0::1 #DEFAULT
define SCON_SUBNET6_CIDR = fd07:b51a:cc66:0::/64 #DEFAULT
define NAT64_SOURCE_IP4 = 10.183.233.241 #DEFAULT
define K8S_MERGED_CIDR4 = 192.168.194.0/24 #DEFAULT
define K8S_MERGED_CIDR6 = fd07:b51a:cc66:a::/64 #DEFAULT

define DOCKER_FWMARK_LOCAL_ROUTE = 0xb3c60000 #DEFAULT
define DOCKER_FWMARK_TPROXY = 0x7d8a0000 #DEFAULT
define DOCKER_FWMARK_TPROXY_OUTBOUND = 0x9f7a0000 #DEFAULT

# all chains have higher prio than docker/k8s iptables-nft
table inet orbstack {
    set docker_bridges {
        type ifname
    }

    set host_bridge_ports {
        type ifname
    }

    set docker_bridge_subnets4 {
        type ipv4_addr
        flags interval
        auto-merge
    }

    set docker_bridge_subnets6 {
        type ipv6_addr
        flags interval
        auto-merge
    }

    # TODO: remove
    set docker_bridge_host_ips4 {
        type ipv4_addr
        elements = { $NAT64_SOURCE_IP4 }
    }

    set docker_bridge_host_ips6 {
        type ipv6_addr
    }

    map domainproxy4 {
        type ipv4_addr : ipv4_addr
    }

    map domainproxy6 {
        type ipv6_addr : ipv6_addr
    }

    flowtable ft {
        hook ingress priority filter
        # TODO: safe to do this for orbmirror, or does return route break?
        devices = { $IF_SCON }
    }

    chain prerouting-mangle {
        type filter hook prerouting priority mangle; policy accept;

        tcp dport 80 meta nftrace set 1

        ct mark $DOCKER_FWMARK_TPROXY_OUTBOUND meta nftrace set 1 meta mark set $DOCKER_FWMARK_LOCAL_ROUTE
        ct mark $DOCKER_FWMARK_TPROXY meta mark set $DOCKER_FWMARK_LOCAL_ROUTE
    }

    chain early-prerouting-dynamic {
        # added dynamically by DockerTlsInitCommands
        #jump early-prerouting-tproxy
    }

    chain early-prerouting-tproxy {
        # TPROXY: redirect incoming port 443 traffic to containers to our proxies
        # exclude our gateway IP (pkttype host) to avoid breaking port forward access
        # match dport 443 first to avoid perf hit on other conns (-10 Gbps)
        #tcp dport 443 ip daddr @docker_bridge_subnets4 ip saddr @docker_bridge_host_ips4 meta mark != $DOCKER_MARK_TLS_PROXY_UPSTREAM counter meta mark set $DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE tproxy ip to $VNET_TLS_PROXY_IP4:$PORT_DOCKER_MACHINE_TLS_PROXY
        #tcp dport 443 ip6 daddr @docker_bridge_subnets6 ip6 saddr @docker_bridge_host_ips6 meta mark != $DOCKER_MARK_TLS_PROXY_UPSTREAM counter meta mark set $DOCKER_MARK_TLS_PROXY_LOCAL_ROUTE tproxy ip6 to $VNET_TLS_PROXY_IP6:$PORT_DOCKER_MACHINE_TLS_PROXY
    }


    chain prerouting {
        type nat hook prerouting priority dstnat - 1; policy accept;

        # 172.17.0.1 IP gateway compat. people hard code this...
        # redirect to local IP on same interface (eth0, i.e. 198.19.249.2 docker machine's external IP)
        # only do so if packet would otherwise go out to internet, in case user is using 172.17/16
        ip daddr 172.17.0.1 fib daddr . mark oif eq $IF_SCON counter redirect

        tcp dport 443 ip daddr @domainproxy4 ct mark set $DOCKER_FWMARK_TPROXY meta mark set $DOCKER_FWMARK_LOCAL_ROUTE accept
        tcp dport 443 ip6 daddr @domainproxy6 ct mark set $DOCKER_FWMARK_TPROXY meta mark set $DOCKER_FWMARK_LOCAL_ROUTE accept

        dnat to ip daddr map @domainproxy4
        dnat to ip6 daddr map @domainproxy6
    }

    chain postrouting {
        type nat hook postrouting priority srcnat - 1; policy accept;

        # "fix" ipv4 docker port forward source IP as seen by container servers:
        # normally docker only does DNAT w/o MASQUERADE to preserve source IP, but our source IP is internal vnet and people expect it to come from the machine like normal linux loopback
        # needed because people make assumptions about source IPs
        ip saddr { $VNET_GATEWAY_IP4, $NAT64_SOURCE_IP4 } iif $IF_SCON counter masquerade
        ip6 saddr $VNET_GATEWAY_IP6 iif $IF_SCON counter masquerade

        # VM can only route the /64 ULA that the machine was assigned
        # masquerade other outgoing IPv6 traffic to fix kind ipv6 access
        # TODO: what was this for???
        ip6 saddr fc00::/7 ip6 saddr != $SCON_SUBNET6_CIDR oif eth0 counter masquerade

        # prevent routing loop: a packet received from macOS bridge must not be sent back to macOS
        # TODO: sometimes k8s packets still loop with this rule, so we need the failsafe in postrouting-dynamic
        iifname @host_bridge_ports oif $IF_SCON counter drop

        # added at boot if k8s is enabled
        #jump postrouting-dynamic
    }

    chain postrouting-dynamic {
        # fix k8s packets leaking to the internet if there's no kube iptables rule for a service IP
        # can happen when pods try to connect to other services before they're up
        # this is also a failsafe for routing loops between vmnet bridges and eth0
        ip daddr $K8S_MERGED_CIDR4 oif $IF_SCON counter drop
        ip6 daddr $K8S_MERGED_CIDR6 oif $IF_SCON counter drop
    }

    chain input-mangle {
        type filter hook input priority mangle; policy accept

        #tcp dport 443 meta nftrace set 1
    }

    chain output-mangle {
        type route hook output priority mangle; policy accept;

        meta mark $DOCKER_FWMARK_TPROXY_OUTBOUND meta nftrace set 1 ct mark set $DOCKER_FWMARK_TPROXY_OUTBOUND
        tcp dport 80 meta nftrace set 1
        #socket transparent 1 meta nftrace set 1 ct mark set $DOCKER_FWMARK_TPROXY_OUTBOUND

        # TLS PROXY - 2. on OUTPUT path, save the OUTGOING mark to conntrack metadata for this 5-tuple
        #meta mark $DOCKER_MARK_TLS_PROXY_UPSTREAM counter ct mark set mark
    }

    chain early-forward {
        type filter hook forward priority filter - 1; policy accept;

        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        meta l4proto { tcp, udp } meta oifkind != "bridge" flow add @ft counter
    }
}

table bridge orbstack_bridge {
    chain prerouting {
        type filter hook prerouting priority -199; policy accept;
        ct mark $DOCKER_FWMARK_TPROXY_OUTBOUND counter meta broute set 1 meta pkttype set host accept;
    }
}
