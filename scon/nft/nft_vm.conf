# special syntax:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_VNET = eth0 #DEFAULT
define IF_BRIDGE = conbr0 #DEFAULT
define INTERNAL_LISTEN_IP4 = 198.19.248.2 #DEFAULT
define INTERNAL_LISTEN_IP6 = fd07:b51a:cc66:f0::2 #DEFAULT
define SCON_WEB_INDEX_IP4 = 198.19.249.1 #DEFAULT
define SCON_WEB_INDEX_IP6 = fd07:b51a:cc66:0::1 #DEFAULT
define SCON_HOST_BRIDGE_IP4 = 198.19.249.3 #DEFAULT
define SCON_HOST_BRIDGE_IP6 = fd07:b51a:cc66:0:a617:db5e:0ab7:e9f1 #DEFAULT
define MAC_DOCKER = 1a:78:30:64:16:a9 #DEFAULT
define VNET_SECURE_SVC_IP4 = 198.19.248.201 #DEFAULT
define PORT_SECURE_SVC_DOCKER_REMOTE_CTX = 2376 #DEFAULT
define SCON_SUBNET4 = 198.19.249.0/24 #DEFAULT
define SCON_SUBNET6 = fd07:b51a:cc66::/64 #DEFAULT
define VNET_SUBNET4 = 198.19.248.0/24 #DEFAULT
define VNET_SUBNET6 = fd07:b51a:cc66:f0::/64 #DEFAULT

define IFGROUP_ISOLATED = 1 #DEFAULT

define MARK_NAT64 = 1 #DEFAULT
define MARK_ISOLATED = 2 #DEFAULT

table inet vm {
    map tcp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map udp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map tcp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    map udp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    flowtable ft {
        hook ingress priority filter
        # these must be bridge *ports*, not bridges, in order for offload hook to run early enough
        # scon will update the list as machines are started/stopped
        # TODO: add eth1. flowtable breaks nat64 reply route
        # no eth2: forwarded packets are in docker machine
        devices = { $IF_VNET }
    }

    chain prerouting-early {
        type filter hook prerouting priority raw; policy accept;

        # reverse path filter for internal services
        # prevents machines from hijacking existing internal TCP conns
        # we don't do this for all IPs for performance, and because it could cause issues with NAT64 fib routing
        # but the vnet subnet is usually not perf critical
        # rule: raw -> [conntrack] -> mangle -> nat -> filter
        # TODO: is conn hijacking even possible?
        ip daddr $VNET_SUBNET4 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
        ip6 daddr $VNET_SUBNET6 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
    }

    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # fast port forwards
        # MASQUERADE not needed
        # this preserves source IP from host vnet, which works due to ip forward
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards4
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards4
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards6
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards6
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # NAT: gvisor only accepts packets with our source IP
        # filtering by output interface fixes multicast
        # can't filter by input interface (-i) in POSTROUTING
        oif $IF_VNET counter masquerade
    }

    chain input {
        type filter hook input priority filter; policy drop;

        # related/established
        ct state established,related counter accept

        # loopback and host: allow mac gvisor vnet to access anything
        iif { lo, $IF_VNET } counter accept

	    # icmp: allow all ICMP for ping and neighbor solicitation
        meta l4proto { icmp, ipv6-icmp } counter accept

        # 67/udp: allow machines to use DHCP v4 server (dnsmasq)
        # 5353/udp: allow machines to use mDNS 2server
        iif $IF_BRIDGE udp dport { 67, 5353 } counter accept

        # allow mac host bridge to access web server ports 80 and 443
        # block isolated machines to avoid info leak
        ip daddr $SCON_WEB_INDEX_IP4 iif $IF_BRIDGE meta mark != $MARK_ISOLATED tcp dport { 80, 443 } counter accept
        ip6 daddr $SCON_WEB_INDEX_IP6 iif $IF_BRIDGE meta mark != $MARK_ISOLATED tcp dport { 80, 443 } counter accept

        # explicitly reject everything else, as if we're not listening
        # there's no "policy reject"
        meta l4proto tcp reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        reject
    }

    chain forward-early {
        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        # NAT64 routing is asymmetric, so exclude
        meta l4proto { tcp, udp } meta mark != $MARK_NAT64 flow add @ft counter

        # related/established
        ct state established,related counter accept
    }

    chain forward-filter {
        # limit access to secure services:
		# allow secureSvcIP:SecureSvcDockerRemoteCtx from docker machine
		# non-isolated machines can already access any socket by running commands on host
        ip daddr $VNET_SECURE_SVC_IP4 iif $IF_BRIDGE meta mark != $MARK_ISOLATED ether saddr $MAC_DOCKER tcp dport $PORT_SECURE_SVC_DOCKER_REMOTE_CTX counter accept
		# block all other secure svc forwards
        meta l4proto tcp ip daddr $VNET_SECURE_SVC_IP4 reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        ip daddr $VNET_SECURE_SVC_IP4 reject
    }

    chain forward {
        type filter hook forward priority filter; policy drop;

        jump forward-early
        jump forward-filter

        # allow normal forwards:
        # - machines to access internet via gvisor
        # - incoming conns from gvisor (if we get rid of NAT)
        # - bridge ports to establish conns with each other
        iif . oif { $IF_BRIDGE . $IF_VNET, $IF_VNET . $IF_BRIDGE, $IF_BRIDGE . $IF_BRIDGE } counter accept
    }
}

table bridge vm_bridge {
    # input = packets passed up to IP stack
    chain input {
        type filter hook input priority filter; policy accept;

        # just mark it here for easier filtering later
        # also reduces overhead on every passed-up packet
        iifgroup $IFGROUP_ISOLATED meta mark set $MARK_ISOLATED
    }
}
