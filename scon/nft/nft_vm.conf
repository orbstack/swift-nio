# special syntax:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_VNET = eth0 #DEFAULT
define IF_VMNET_MACHINE = eth1 #DEFAULT
define IF_BRIDGE = conbr0 #DEFAULT
define INTERNAL_LISTEN_IP4 = 0.250.250.2 #DEFAULT
define INTERNAL_LISTEN_IP6 = fd07:b51a:cc66:f0::2 #DEFAULT
define SCON_WEB_INDEX_IP4 = 198.19.249.1 #DEFAULT
define SCON_WEB_INDEX_IP6 = fd07:b51a:cc66:0::1 #DEFAULT
define SCON_HOST_BRIDGE_IP4 = 198.19.249.3 #DEFAULT
define SCON_HOST_BRIDGE_IP6 = fd07:b51a:cc66:0:a617:db5e:0ab7:e9f1 #DEFAULT
define MAC_DOCKER = 1a:78:30:64:16:a9 #DEFAULT
define VNET_SECURE_SVC_IP4 = 0.250.250.201 #DEFAULT
define SCON_SUBNET4 = 198.19.249.0/24 #DEFAULT
define SCON_SUBNET6 = fd07:b51a:cc66::/64 #DEFAULT
define VNET_SUBNET4 = 0.250.250.0/24 #DEFAULT
define VNET_SUBNET6 = fd07:b51a:cc66:f0::/64 #DEFAULT
define DOMAINPROXY_SUBNET4 = 198.19.248.0/24 #DEFAULT
define DOMAINPROXY_SUBNET6 = fd07:b51a:cc66:0:cafe::/112 #DEFAULT

define IFGROUP_ISOLATED = 1 #DEFAULT

define FWMARK_DOCKER_ROUTE_BIT = 0x1 #DEFAULT
define FWMARK_LOCAL_ROUTE_BIT = 0x2 #DEFAULT
define FWMARK_TPROXY_OUTBOUND_BIT = 0x4 #DEFAULT
define FWMARK_ISOLATED_BIT = 0x8 #DEFAULT
define FWMARK_HAIRPIN_MASQUERADE_BIT = 0x10 #DEFAULT
define FWMARK_NFQUEUE_SKIP_BIT = 0x20 #DEFAULT

define QUEUE_DOMAINPROXY_PROBE = 23478 #DEFAULT

table inet orbstack {
    map tcp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }
    map tcp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    map udp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }
    map udp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    # this stores the upstreams for domainproxy ips
    map domainproxy4 {
        type ipv4_addr : ipv4_addr
    }
    map domainproxy6 {
        type ipv6_addr : ipv6_addr
    }

    set domainproxy4_probed_tls {
        type ipv4_addr
    }
    set domainproxy6_probed_tls {
        type ipv6_addr
    }

    map domainproxy4_probed_http_upstreams {
        type ipv4_addr : ipv4_addr . inet_service
    }
    map domainproxy6_probed_http_upstreams {
        type ipv6_addr : ipv6_addr . inet_service
    }

    # ips in these sets are routed to docker
    set domainproxy4_docker {
        type ipv4_addr
    }
    set domainproxy6_docker {
        type ipv6_addr
    }

    # this is essentially the same as the map, except as a concat set. this lets us check when traffic should be routed back to the same machine
    set domainproxy4_masquerade {
        type ipv4_addr . ipv4_addr
    }
    set domainproxy6_masquerade {
        type ipv6_addr . ipv6_addr
    }

    flowtable ft {
        hook ingress priority filter
        # these must be bridge *ports*, not bridges, in order for offload hook to run early enough
        # scon will update the list as machines are started/stopped
        # TODO: add eth1. flowtable breaks nat64 reply route
        # no eth2: forwarded packets are in docker machine
        devices = { $IF_VNET }
    }

    chain prerouting-raw {
        type filter hook prerouting priority raw; policy accept;

        # reverse path filter for internal services
        # prevents machines from hijacking existing internal TCP conns
        # we don't do this for all IPs for performance, and because it could cause issues with NAT64 fib routing
        # but the vnet subnet is usually not perf critical
        # rule: raw -> [conntrack] -> mangle -> nat -> filter
        # TODO: is conn hijacking even possible?
        ip daddr $VNET_SUBNET4 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
        ip6 daddr $VNET_SUBNET6 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
    }

    chain prerouting-mangle {
        type filter hook prerouting priority mangle; policy accept;

        # this needs to be in mangle because raw happens before conntrack, so we can't access conntrack marks there
        # restore $FWMARK_DOCKER_ROUTE from ctmark
        # otherwise, the first packet gets routed but none of the rest do
        ct mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT

        # asymmetrical tproxy routing
        # this hijacks return traffic that was sent outbound by tproxy
        ct mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter meta mark set $FWMARK_LOCAL_ROUTE_BIT
    }

    chain prerouting-tlsproxy {
        # accept traffic that has been probed
        # this skips dnat so traffic gets received by tproxy
        # we don't need local_route because domainproxy ips are set to route to lo anyways (they're anyip)
        ip daddr @domainproxy4_probed_tls counter accept
        ip6 daddr @domainproxy6_probed_tls counter accept

        # nfqueue: let userspace probe upstream ports to simulate conditional accept for tproxy (i.e. RST if upstream would send RST, only accept if upstream 80/443 exists)
        # important because happy eyeballs relies on a failed v6 connection to fall back to v4
        # if it hasn't been probed, probe it. the verdict for this is always repeat with the skip mark
        # if the probe succeeds, the host will be added to the domainproxy_probed sets, which will cause the packet to be accepted on repeat
        # otherwise, processing will continue on
        # no bypass: if queue overflows, make user wait for upstream probe to finish, rather than incorrectly letting them connect to the proxy
        meta mark & $FWMARK_NFQUEUE_SKIP_BIT == 0 counter queue num $QUEUE_DOMAINPROXY_PROBE

        # since the host was not added to the probed sets, it was a reject
        counter reject with tcp reset
    }

    chain prerouting-dynamic-tlsproxy {
        # added dynamically by mdnsRegistry
        #jump prerouting-tproxy
    }

    chain prerouting-domainproxy-http {
        meta l4proto tcp counter dnat ip to ip daddr map @domainproxy4_probed_http_upstreams
        meta l4proto tcp counter dnat ip6 to ip6 daddr map @domainproxy6_probed_http_upstreams

        meta mark & $FWMARK_NFQUEUE_SKIP_BIT == 0 counter queue num $QUEUE_DOMAINPROXY_PROBE

        counter reject with tcp reset
    }

    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # fast port forwards
        # MASQUERADE not needed
        # this preserves source IP from host vnet, which works due to ip forward
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards4
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards4
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards6
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards6

        # when tlsproxy is enabled, this chain will use nfqueue to probe and then may accept the packet without dnatting so that it can be received by tproxy bpf
        tcp dport 443 ip daddr @domainproxy4 counter jump prerouting-dynamic-tlsproxy
        tcp dport 443 ip6 daddr @domainproxy6 counter jump prerouting-dynamic-tlsproxy

        # if a packet is being sent to a domainproxy ip corresponding to a docker container, add the docker route bit so that it gets routed to the docker machine
        ip daddr @domainproxy4_docker counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT
        ip6 daddr @domainproxy6_docker counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT

        # check whether a machine is trying to reach its own domainproxy ip
        # if so, we need to masquerade so the return gets routed through ovm
        ip daddr . ip saddr @domainproxy4_masquerade counter meta mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT
        ip6 daddr . ip6 saddr @domainproxy6_masquerade counter meta mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT

        # probe for http proxy and dnat to the right port. this needs to be after all the relevant marking
        tcp dport 80 ip daddr @domainproxy4 counter jump prerouting-domainproxy-http
        tcp dport 80 ip6 daddr @domainproxy6 counter jump prerouting-domainproxy-http

        # this will only succeed if the daddr is in the domainproxy map
        # this is where we direct domainproxy traffic where it's actually supposed to be going
        dnat to ip daddr map @domainproxy4
        dnat to ip6 daddr map @domainproxy6
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # NAT: gvisor only accepts packets with our source IP
        # filtering by output interface fixes multicast
        # can't filter by input interface (-i) in POSTROUTING
        oif $IF_VNET counter masquerade

        # when a machine sends packets to its own domainproxy ip, we need to masquerade so that we will receive the response packets
        ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 counter masquerade

        # store $FWMARK_DOCKER_ROUTE as ctmark
        meta mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter ct mark set mark | $FWMARK_DOCKER_ROUTE_BIT
    }

    chain input {
        type filter hook input priority filter; policy drop;

        # related/established
        ct state established,related counter accept

        # loopback and host: allow mac gvisor vnet to access anything
        iif { lo, $IF_VNET } counter accept

        # allow tproxy stuff through
        tcp dport 443 ip daddr @domainproxy4 counter accept
        tcp dport 443 ip6 daddr @domainproxy6 counter accept

        # prevent ovm from responding to stuff intended for domainproxy
        ip daddr $DOMAINPROXY_SUBNET4 counter drop
        ip6 daddr $DOMAINPROXY_SUBNET6 counter drop

	    # icmp: allow all ICMP for ping and neighbor solicitation
        meta l4proto { icmp, ipv6-icmp } counter accept

        # 67/udp: allow machines to use DHCP v4 server (dnsmasq)
        # 5353/udp: allow machines to use mDNS 2server
        iif $IF_BRIDGE udp dport { 67, 5353 } counter accept

        # allow mac host bridge to access web server ports 80 and 443
        # block isolated machines to avoid info leak
        ip daddr $SCON_WEB_INDEX_IP4 iif $IF_BRIDGE meta mark & $FWMARK_ISOLATED_BIT == 0 tcp dport { 80, 443 } counter accept
        ip6 daddr $SCON_WEB_INDEX_IP6 iif $IF_BRIDGE meta mark & $FWMARK_ISOLATED_BIT == 0 tcp dport { 80, 443 } counter accept

        # explicitly reject everything else, as if we're not listening
        # there's no "policy reject"
        meta l4proto tcp reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        reject
    }

    chain forward-early {
        meta mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 ct mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT

        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        # NAT64 routing is asymmetric, so exclude
        # for some reason hairpin traffic breaks
        meta l4proto { tcp, udp } meta mark & $FWMARK_DOCKER_ROUTE_BIT == 0 ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT == 0 flow add @ft counter

        # related/established
        ct state established,related counter accept
    }

    chain forward-filter {
        # block access to secure services
        meta l4proto tcp ip daddr $VNET_SECURE_SVC_IP4 reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        ip daddr $VNET_SECURE_SVC_IP4 reject
        # domainproxy hairpin traffic gets attributed to the bridgeport instead of the bridge interface because of broute, so we accept it manually here
        ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 counter accept
    }

    chain forward {
        type filter hook forward priority filter; policy drop;

        jump forward-early
        jump forward-filter

        # allow normal forwards:
        # - conbr0->eth0: machines to access internet via gvisor
        # - eth0->conbr0: incoming conns from gvisor (if we get rid of NAT)
        # - eth1<->conbr0: NAT64 can sometimes show up as forwards despite being a bridge port
        # - conbr0->conbr0: all forwards between bridge ports
        iif . oif {
            $IF_BRIDGE . $IF_VNET,
            $IF_VNET . $IF_BRIDGE,
            $IF_BRIDGE . $IF_VMNET_MACHINE,
            $IF_VMNET_MACHINE . $IF_BRIDGE,
            $IF_BRIDGE . $IF_BRIDGE
        } counter accept
    }

    chain output-mangle {
        type route hook output priority mangle; policy accept;

        # tproxy sends outbound traffic with this mark bit set using SO_MARK
        # this lets us know we need to hijack return traffic to lo
        meta mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter ct mark set mark | $FWMARK_TPROXY_OUTBOUND_BIT
        # tproxy sets this mark bit with SO_MARK if the destinatino is a docker container and thus needs to be routed to the docker machine
        meta mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter ct mark set mark | $FWMARK_DOCKER_ROUTE_BIT
    }
}

table bridge orbstack_bridge {
    set domainproxy4_masquerade_bridge {
        type ipv4_addr . ipv4_addr
    }

    set domainproxy6_masquerade_bridge {
        type ipv6_addr . ipv6_addr
    }

    chain prerouting {
        type filter hook prerouting priority 0; policy accept;

        # broute tproxy return traffic
        # otherwise, it gets directed back to its spoofed source by the bridge before it can be hijacked to lo
        ct mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter meta broute set 1 meta pkttype set host accept

        # broute hairpin traffic
        # without this, we can't do snat (masquerade) because conntrack is finalized too early
        ip daddr . ip saddr @domainproxy4_masquerade_bridge counter meta broute set 1 meta pkttype set host accept
        ip6 daddr . ip6 saddr @domainproxy6_masquerade_bridge counter meta broute set 1 meta pkttype set host accept
    }

    # input = packets passed up to IP stack
    chain input {
        type filter hook input priority filter; policy accept;

        # just mark it here for easier filtering later
        # also reduces overhead on every passed-up packet
        iifgroup $IFGROUP_ISOLATED meta mark set mark | $FWMARK_ISOLATED_BIT
    }
}
