# special syntax:
# - scon removes #DEFAULT defines, to inject constants
# - scon removes " counter" for perf
# - we avoid proper templates, so that this is valid for quick "nft -f" testing

flush ruleset

define IF_VNET = eth0 #DEFAULT
define IF_VMNET_MACHINE = eth1 #DEFAULT
define IF_BRIDGE = conbr0 #DEFAULT
define INTERNAL_LISTEN_IP4 = 0.250.250.2 #DEFAULT
define INTERNAL_LISTEN_IP6 = fd07:b51a:cc66:f0::2 #DEFAULT
define SCON_WEB_INDEX_IP4 = 198.19.249.1 #DEFAULT
define SCON_WEB_INDEX_IP6 = fd07:b51a:cc66:0::1 #DEFAULT
define SCON_HOST_BRIDGE_IP4 = 198.19.249.3 #DEFAULT
define SCON_HOST_BRIDGE_IP6 = fd07:b51a:cc66:0:a617:db5e:0ab7:e9f1 #DEFAULT
define MAC_DOCKER = 1a:78:30:64:16:a9 #DEFAULT
define VNET_SECURE_SVC_IP4 = 0.250.250.201 #DEFAULT
define PORT_SECURE_SVC_DOCKER_REMOTE_CTX = 2376 #DEFAULT
define SCON_SUBNET4 = 198.19.249.0/24 #DEFAULT
define SCON_SUBNET6 = fd07:b51a:cc66::/64 #DEFAULT
define VNET_SUBNET4 = 0.250.250.0/24 #DEFAULT
define VNET_SUBNET6 = fd07:b51a:cc66:f0::/64 #DEFAULT
define DOMAINPROXY_SUBNET4 = 198.19.248.0/24 #DEFAULT
define DOMAINPROXY_SUBNET6 = fd07:b51a:cc66:0:a834:cdb8:ee73::/112 #DEFAULT

define IFGROUP_ISOLATED = 1 #DEFAULT

define FWMARK_DOCKER_ROUTE_BIT = 0x1 #DEFAULT
define FWMARK_LOCAL_ROUTE_BIT = 0x2 #DEFAULT
define FWMARK_TPROXY_OUTBOUND_BIT = 0x4 #DEFAULT
define FWMARK_ISOLATED_BIT = 0x8 #DEFAULT
define FWMARK_HAIRPIN_MASQUERADE_BIT = 0x10 #DEFAULT

table inet vm {
    map tcp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map udp_port_forwards4 {
        type inet_service : ipv4_addr . inet_service
    }

    map tcp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    map udp_port_forwards6 {
        type inet_service : ipv6_addr . inet_service
    }

    # this stores the upstreams for domainproxy ips
    map domainproxy4 {
        type ipv4_addr : ipv4_addr
    }

    map domainproxy6 {
        type ipv6_addr : ipv6_addr
    }

    # ips in these sets are routed to docker
    set domainproxy4_docker {
        type ipv4_addr
    }

    set domainproxy6_docker {
        type ipv6_addr
    }

    # this is essentially the same as the map, except as a concat set. this lets us check when traffic should be routed back to the same machine
    set domainproxy4_masquerade {
        type ipv4_addr . ipv4_addr
    }

    set domainproxy6_masquerade {
        type ipv6_addr . ipv6_addr
    }

    flowtable ft {
        hook ingress priority filter
        # these must be bridge *ports*, not bridges, in order for offload hook to run early enough
        # scon will update the list as machines are started/stopped
        # TODO: add eth1. flowtable breaks nat64 reply route
        # no eth2: forwarded packets are in docker machine
        devices = { $IF_VNET }
    }

    chain prerouting-raw {
        type filter hook prerouting priority raw; policy accept;

        # reverse path filter for internal services
        # prevents machines from hijacking existing internal TCP conns
        # we don't do this for all IPs for performance, and because it could cause issues with NAT64 fib routing
        # but the vnet subnet is usually not perf critical
        # rule: raw -> [conntrack] -> mangle -> nat -> filter
        # TODO: is conn hijacking even possible?
        ip daddr $VNET_SUBNET4 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
        ip6 daddr $VNET_SUBNET6 iif $IF_BRIDGE fib saddr . iif oif eq 0 counter drop
    }

    chain prerouting-mangle {
        type filter hook prerouting priority mangle; policy accept;

        # this needs to be in mangle because raw happens before conntrack, so we can't access conntrack marks there
        # restore $FWMARK_DOCKER_ROUTE from ctmark
        # otherwise, the first packet gets routed but none of the rest do
        ct mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT

        # asymmetrical tproxy routing
        # this hijacks return traffic that was sent outbound by tproxy
        ct mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter meta mark set $FWMARK_LOCAL_ROUTE_BIT
    }

    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # fast port forwards
        # MASQUERADE not needed
        # this preserves source IP from host vnet, which works due to ip forward
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards4
        ip daddr $INTERNAL_LISTEN_IP4 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards4
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to tcp dport map @tcp_port_forwards6
        ip6 daddr $INTERNAL_LISTEN_IP6 iif $IF_VNET counter dnat to udp dport map @udp_port_forwards6

        # clear other flags
        # this marks a packet as being destined for tproxy
        # we don't need local_route because domainproxy ips are set to route to lo anyways (they're anyip)
        # the conntrack mark is so we can accept other tproxy traffic
        tcp dport 443 ip daddr @domainproxy4 counter accept
        tcp dport 443 ip6 daddr @domainproxy6 counter accept

        # check whether a machine is trying to reach its own domainproxy ip
        # if so, we need to masquerade so the return gets routed through ovm
        ip daddr . ip saddr @domainproxy4_masquerade counter meta mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT
        ip6 daddr . ip6 saddr @domainproxy6_masquerade counter meta mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT

        # if a packet is being sent to a domainproxy ip corresponding to a docker container, add the docker route bit so that it gets routed to the docker machine
        ip daddr @domainproxy4_docker counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT
        ip6 daddr @domainproxy6_docker counter meta mark set mark | $FWMARK_DOCKER_ROUTE_BIT

        # this will only succeed if the daddr is in the domainproxy map
        # this is where we direct domainproxy traffic where it's actually supposed to be going
        dnat to ip daddr map @domainproxy4
        dnat to ip6 daddr map @domainproxy6
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # NAT: gvisor only accepts packets with our source IP
        # filtering by output interface fixes multicast
        # can't filter by input interface (-i) in POSTROUTING
        oif $IF_VNET counter masquerade

        # when a machine sends packets to its own domainproxy ip, we need to masquerade so that we will receive the response packets
        ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 counter masquerade

        # store $FWMARK_DOCKER_ROUTE as ctmark
        meta mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter ct mark set mark | $FWMARK_DOCKER_ROUTE_BIT
    }

    chain input {
        type filter hook input priority filter; policy drop;

        # related/established
        ct state established,related counter accept

        # loopback and host: allow mac gvisor vnet to access anything
        iif { lo, $IF_VNET } counter accept

        # allow tproxy stuff through
        tcp dport 443 ip daddr @domainproxy4 counter accept
        tcp dport 443 ip6 daddr @domainproxy6 counter accept

        # prevent ovm from responding to stuff intended for domainproxy
        ip daddr $DOMAINPROXY_SUBNET4 counter drop
        ip6 daddr $DOMAINPROXY_SUBNET6 counter drop

	    # icmp: allow all ICMP for ping and neighbor solicitation
        meta l4proto { icmp, ipv6-icmp } counter accept

        # 67/udp: allow machines to use DHCP v4 server (dnsmasq)
        # 5353/udp: allow machines to use mDNS 2server
        iif $IF_BRIDGE udp dport { 67, 5353 } counter accept

        # allow mac host bridge to access web server ports 80 and 443
        # block isolated machines to avoid info leak
        ip daddr $SCON_WEB_INDEX_IP4 iif $IF_BRIDGE meta mark & $FWMARK_ISOLATED_BIT == 0 tcp dport { 80, 443 } counter accept
        ip6 daddr $SCON_WEB_INDEX_IP6 iif $IF_BRIDGE meta mark & $FWMARK_ISOLATED_BIT == 0 tcp dport { 80, 443 } counter accept

        # explicitly reject everything else, as if we're not listening
        # there's no "policy reject"
        meta l4proto tcp reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        reject
    }

    chain forward-early {
        meta mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 ct mark set mark | $FWMARK_HAIRPIN_MASQUERADE_BIT

        # fastpath for forwarding and NAT: skip most of net stack after first reply packet
        # NAT64 routing is asymmetric, so exclude
        # for some reason hairpin traffic breaks
        meta l4proto { tcp, udp } meta mark & $FWMARK_DOCKER_ROUTE_BIT == 0 ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT == 0 flow add @ft counter

        # related/established
        ct state established,related counter accept
    }

    chain forward-filter {
        # limit access to secure services:
        # allow secureSvcIP:SecureSvcDockerRemoteCtx from docker machine
        # non-isolated machines can already access any socket by running commands on host
        ip daddr $VNET_SECURE_SVC_IP4 iif $IF_BRIDGE meta mark & $FWMARK_ISOLATED_BIT != 0 ether saddr $MAC_DOCKER tcp dport $PORT_SECURE_SVC_DOCKER_REMOTE_CTX counter accept
        # block all other secure svc forwards
        meta l4proto tcp ip daddr $VNET_SECURE_SVC_IP4 reject with tcp reset
        # fallback: ICMP port unreachable for other protos
        ip daddr $VNET_SECURE_SVC_IP4 reject
        # domainproxy hairpin traffic gets attributed to the bridgeport instead of the bridge interface because of broute, so we accept it manually here
        ct mark & $FWMARK_HAIRPIN_MASQUERADE_BIT != 0 counter accept
    }

    chain forward {
        type filter hook forward priority filter; policy drop;

        jump forward-early
        jump forward-filter

        # allow normal forwards:
        # - conbr0->eth0: machines to access internet via gvisor
        # - eth0->conbr0: incoming conns from gvisor (if we get rid of NAT)
        # - eth1<->conbr0: NAT64 can sometimes show up as forwards despite being a bridge port
        # - conbr0->conbr0: all forwards between bridge ports
        iif . oif {
            $IF_BRIDGE . $IF_VNET,
            $IF_VNET . $IF_BRIDGE,
            $IF_BRIDGE . $IF_VMNET_MACHINE,
            $IF_VMNET_MACHINE . $IF_BRIDGE,
            $IF_BRIDGE . $IF_BRIDGE
        } counter accept
    }

    chain output-mangle {
        type route hook output priority mangle; policy accept;

        # tproxy sends outbound traffic with this mark bit set using SO_MARK
        # this lets us know we need to hijack return traffic to lo
        meta mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter ct mark set mark | $FWMARK_TPROXY_OUTBOUND_BIT
        # tproxy sets this mark bit with SO_MARK if the destinatino is a docker container and thus needs to be routed to the docker machine
        meta mark & $FWMARK_DOCKER_ROUTE_BIT != 0 counter ct mark set mark | $FWMARK_DOCKER_ROUTE_BIT
    }
}

table bridge vm_bridge {
    set domainproxy4_masquerade_bridge {
        type ipv4_addr . ipv4_addr
    }

    set domainproxy6_masquerade_bridge {
        type ipv6_addr . ipv6_addr
    }

    chain prerouting {
        type filter hook prerouting priority 0; policy accept;

        # broute tproxy return traffic
        # otherwise, it gets directed back to its spoofed source by the bridge before it can be hijacked to lo
        ct mark & $FWMARK_TPROXY_OUTBOUND_BIT != 0 counter meta broute set 1 meta pkttype set host accept
        # broute hairpin traffic
        # without this, we can't do snat (masquerade) because conntrack is finalized too early
        ip daddr . ip saddr @domainproxy4_masquerade_bridge counter meta broute set 1 meta pkttype set host accept
        ip6 daddr . ip6 saddr @domainproxy6_masquerade_bridge counter meta broute set 1 meta pkttype set host accept
    }

    # input = packets passed up to IP stack
    chain input {
        type filter hook input priority filter; policy accept;

        # just mark it here for easier filtering later
        # also reduces overhead on every passed-up packet
        iifgroup $IFGROUP_ISOLATED meta mark set mark | $FWMARK_ISOLATED_BIT
    }
}
