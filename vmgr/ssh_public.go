package main

import (
	"crypto/ed25519"
	"encoding/pem"
	"errors"
	"fmt"
	"os"
	"strconv"

	"github.com/alessio/shellescape"
	"github.com/mikesmitty/edkey"
	"github.com/orbstack/macvirt/vmgr/conf"
	"github.com/orbstack/macvirt/vmgr/conf/appid"
	"github.com/orbstack/macvirt/vmgr/conf/ports"
	"github.com/orbstack/macvirt/vmgr/syssetup"
	"github.com/orbstack/macvirt/vmgr/util"
	"github.com/orbstack/macvirt/vmgr/util/sshconfig"
	"github.com/sirupsen/logrus"
	"golang.org/x/crypto/ssh"
)

func generatePublicSSHKey() error {
	pk, sk, err := ed25519.GenerateKey(nil)
	if err != nil {
		return err
	}

	sshPk, err := ssh.NewPublicKey(pk)
	if err != nil {
		return err
	}

	pemKey := &pem.Block{
		Type:  "OPENSSH PRIVATE KEY",
		Bytes: edkey.MarshalED25519PrivateKey(sk),
	}
	sshSkText := pem.EncodeToMemory(pemKey)
	sshPkText := ssh.MarshalAuthorizedKey(sshPk)

	err = os.WriteFile(conf.ExtraSshDir()+"/id_ed25519", sshSkText, 0600)
	if err != nil {
		return err
	}
	err = os.WriteFile(conf.ExtraSshDir()+"/id_ed25519.pub", sshPkText, 0644)
	if err != nil {
		return err
	}

	return nil
}

func setupPublicSSH() error {
	// ssh-predicate is to ensure VM start
	exePath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("find executable: %w", err)
	}

	relHome := syssetup.MakeHomeRelative(conf.ExtraSshDir())
	quotedCmd := shellescape.QuoteCommand([]string{exePath, "ssh-predicate", strconv.Itoa(os.Getuid())})
	sshConfigSection := fmt.Sprintf(`# AUTO-GENERATED BY ORBSTACK. DO NOT EDIT.
# To make changes, add or override hosts at the top of ~/.ssh/config

Match originalhost %s exec "%s"
Host %s
  Hostname 127.0.0.1
  Port %d
  # SSH user syntax:
  #   <container>@%s to connect to <container> as the default user (matching your macOS user)
  #   <user>@<container>@%s to connect to <container> as <user>
  # Examples:
  #   ubuntu@%s: container "ubuntu", user matching your macOS user
  #   root@fedora@%s: container "fedora", user "root"
  User default
  # replace or symlink %s/id_ed25519 file to change the key
  IdentityFile %s/id_ed25519
  # only use this key
  IdentitiesOnly yes
`, appid.ShortAppName, quotedCmd, appid.ShortAppName, ports.HostSconSSHPublic, appid.ShortAppName, appid.ShortAppName, appid.ShortAppName, appid.ShortAppName, relHome, relHome)

	// debug VM ssh server
	if conf.Debug() {
		sshConfigSection += `
Host ovm
  Hostname 127.0.0.1
  User root
  Port 2222
`
	}

	// write extra config atomically - openssh reads it on-demand after match
	err = util.WriteFileAtomic(conf.ExtraSshDir()+"/config", []byte(sshConfigSection), 0644)
	if err != nil {
		return err
	}

	// generate key if necessary
	_, err1 := os.Stat(conf.ExtraSshDir() + "/id_ed25519")
	_, err2 := os.Stat(conf.ExtraSshDir() + "/id_ed25519.pub")
	if errors.Is(err1, os.ErrNotExist) || errors.Is(err2, os.ErrNotExist) {
		err = generatePublicSSHKey()
		if err != nil {
			return err
		}
	}

	// check for existing "orb" host
	// incl. Include and empty Host blocks
	oldHostname, err := sshconfig.ReadKeyForHost(appid.ShortAppName, "Hostname")
	if err != nil {
		logrus.WithError(err).Warn("failed to parse SSH config")
		return err
	}
	logrus.WithField("oldHostname", oldHostname).Debug("oldHostname")

	// default = same as we provided
	if oldHostname == appid.ShortAppName {
		// add include if necessary
		userConfigPath := conf.UserSshDir() + "/config"
		sshConfig, err := os.ReadFile(userConfigPath)
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				sshConfig = []byte{}
			} else {
				return err
			}
		}

		// prepend, or it doesn't work
		includeLine := fmt.Sprintf("Include %s/config", syssetup.MakeHomeRelative(conf.ExtraSshDir()))
		sshConfig = append([]byte(includeLine+"\n\n"), sshConfig...)
		err = os.WriteFile(userConfigPath, sshConfig, 0644)
		// ignore permission errors and warn in case user has nix home-manager for .ssh
		if err != nil {
			if errors.Is(err, os.ErrPermission) {
				logrus.WithError(err).Warn("failed to add include for SSH config snippet")
			} else {
				return err
			}
		}
	}

	return nil
}
