package vmgr

import (
	"errors"
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/alessio/shellescape"
	"github.com/orbstack/macvirt/vmgr/conf"
	"github.com/orbstack/macvirt/vmgr/conf/appid"
	"github.com/orbstack/macvirt/vmgr/conf/ports"
	"github.com/orbstack/macvirt/vmgr/syssetup"
	"github.com/orbstack/macvirt/vmgr/util"
	"github.com/orbstack/macvirt/vmgr/util/sshconfig"
	"github.com/orbstack/macvirt/vmgr/vmconfig"
	"github.com/sirupsen/logrus"
)

func (s *VmControlServer) setupPublicSSH() error {
	// generate key first -- don't write config pointing to non-existent key
	err := s.hcontrol.InternalEnsurePublicSSHKey()
	if err != nil {
		return err
	}

	// ssh-proxy-fdpass is to ensure VM start
	exePath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("find executable: %w", err)
	}

	relHome := syssetup.MakeHomeRelative(conf.ExtraSshDir())
	quotedCmd := shellescape.QuoteCommand([]string{exePath, "ssh-proxy-fdpass", strconv.Itoa(os.Getuid())})
	sshConfigSection := fmt.Sprintf(`# AUTO-GENERATED BY ORBSTACK. DO NOT EDIT.
# To make changes, add or override hosts at the top of ~/.ssh/config

Host %s
  Hostname 127.0.0.1
  Port %d
  # SSH user syntax:
  #   <container>@%s to connect to <container> as the default user (matching your macOS user)
  #   <user>@<container>@%s to connect to <container> as <user>
  # Examples:
  #   ubuntu@%s: container "ubuntu", user matching your macOS user
  #   root@fedora@%s: container "fedora", user "root"
  User default
  # replace or symlink %s/id_ed25519 file to change the key
  IdentityFile %s/id_ed25519
  # only use this key
  IdentitiesOnly yes
  UserKnownHostsFile %s/known_hosts
  ProxyCommand %s
  ProxyUseFdpass yes
`, appid.ShortAppName, ports.HostSconSSHPublic, appid.ShortAppName, appid.ShortAppName, appid.ShortAppName, appid.ShortAppName, relHome, relHome, relHome, quotedCmd)

	// debug VM ssh server
	if conf.Debug() {
		sshConfigSection += fmt.Sprintf(`
Host ovm
  Hostname 127.0.0.1
  User root
  Port 2222
  IdentityFile %s/id_ed25519
`, relHome)
	}

	// write extra config atomically - openssh reads it on-demand after match
	err = util.WriteFileAtomic(conf.ExtraSshDir()+"/config", []byte(sshConfigSection), 0644)
	if err != nil {
		return err
	}

	// check for existing "orb" host
	// incl. Include and empty Host blocks
	oldHostname, err := sshconfig.ReadKeyForHost(appid.ShortAppName, "Hostname")
	if err != nil {
		logrus.WithError(err).Warn("failed to parse SSH config")
		return err
	}
	logrus.WithField("oldHostname", oldHostname).Debug("oldHostname")

	// default = same as we provided
	if oldHostname == appid.ShortAppName {
		// add include if necessary
		userConfigPath := conf.UserSshDir() + "/config"
		sshConfig, err := os.ReadFile(userConfigPath)
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				sshConfig = []byte{}
			} else {
				return err
			}
		}

		// don't add if it's already there
		lineBase := fmt.Sprintf("Include %s/config", syssetup.MakeHomeRelative(conf.ExtraSshDir()))
		if strings.Contains(string(sshConfig), lineBase) {
			return nil
		}

		// if we've already tried to add it, don't add it again
		if vmconfig.GetState().SetupState.SshEdited {
			logrus.Infof("not editing ssh config (%s), as we have already done so once", userConfigPath)
			return nil
		}

		// prepend, or it doesn't work
		sshConfig = append([]byte(fmt.Sprintf("# Added by %s: 'orb' SSH host for Linux machines\n# This only works if it's at the top of ssh_config (before any Host blocks).\n# This won't be added again if you remove it.\n%s\n\n", appid.UserAppName, lineBase)), sshConfig...)
		err = os.WriteFile(userConfigPath, sshConfig, 0644)
		// ignore permission errors and warn in case user has nix home-manager for .ssh
		if err != nil {
			if errors.Is(err, os.ErrPermission) {
				logrus.WithError(err).Warn("failed to add include for SSH config snippet")
			} else {
				return err
			}
		}

		// record that we've edited ssh before
		err = vmconfig.UpdateState(func(state *vmconfig.VmgrState) error {
			state.SetupState.SshEdited = true
			return nil
		})
		if err != nil {
			return err
		}
	}

	return nil
}
